\section{Введение}
Логика~--- довольно старая наука, но наш предмет довольно молодой.
В какой-то момент логики как дисциплины, которая учит просто правильно рассуждать, стало нехватать.
Появилась теория множеств и общего здравого смысла оказалось не достаточно, нужен строгий математичесий язык. 
Это рубеж 19-20 веков.

% У нас теория множеств не будет фокусом, как это могло бы быть на мат. факультете.
Теория множеств, когда она была впервые сформулирована, была противоречива (как матан, сформулированный Ньютоном).
Чтобы уверенно и эффективно заниматься матаном, нужно суметь его формализовать. 

Парадокс Рассела или парадокс брадобрея --- один пример парадокса в наивной теории множеств.
Определим множество 
\[ A = \{ X | X \notin X \}\]
Вопрос, принадлежит ли само $A$ множеству $A$, неразрешим~--- 
оба варианта ответа (принадлежит / не принадлежит) приводят к противоречию с определением $A$.

У этого парадокса есть другая формулировка. 
На острове брадобрей бреет всех, кто не бреется сам. 
Вопрос~--- бреет ли брадобрей сам себя? 

Мы приписываем элементу-человеку свойство, которое невыполнимо.
Обьект, выходит, не существует.
Мы смогли очень быстро определить противоречие в этом определении.
Но, может быть, мы не смогли его определить в других наших определениях
(конструкциях вещественной прямой, и т.д и т.д)?

В связи с этим была сформулирована программа Гильберта:
\begin{enumerate}
\item Формализуем математику!
Сформулируем теорию на языке (не на русском или английском), который не будет допускать парадоксов, 
\item $\ldots$ и на котором можно будует доказать непротиворечивость. 
\end{enumerate}
В 1930 году становится понятно, что про сколько-нибудь сильную теорию (т.е ту, в которой можно построить формальную арифметику) нельзя доказать, что она непротиворечивая.

Возможно, сама наша логика неправильная? 
Эта идея будет нам полезна, и к ней мы ещё вернемся.
Возможно, что недоказуемость непротиворечивости~--- просто свойство нашего мира, и мы хотим невозможного.
Из этих рассуждений выросло большое множество хороших идей, 
которые оказались полезны и в других местах.

Матлогика служит широкому кругу нужд.
Мы можем доказывать, что программа работает корректно. 
Именно доказывать, а не проверять тестами!

Мы можем изучать свойства самих языков.
Изоморфизм Карри-Говарда--- доказательство это программа, утверждения это тип.
Можно изучать языки программирования и можно развернуть изоморфизм: изучать математику как язык программирования. 

Функциональные языки: Ocaml + Haskell. 
Ознакомление с этими языками преставляет собой способ ознакомиться с предметом немного с другой стороны.

\section{Исчисление высказываний}
Мы говоирм на двух языках: на предметном языке и метаязыке.
Предметный язык~--- это то, что изучается, а метаязык~--- это язык, \textbf{на} котором это изучается.

На уроках английского предметным является сам английский, а метаязыком может быть русский.
Метаязык~--- это язык исследователя, а предметный язык~--- это язык исследуемого.
Что такое язык вообще? Хороший вопрос.

Высказывание~--- это одно из двух: 
\begin{enumerate}
\item Большая латниская буква начала алфавита, возможно с индексами и штрихами~--- это пропозициональные переменные;
\item Выражение вида $(\alpha \land \beta)$, $(\alpha \lor \beta)$, $(\alpha \to \beta)$, $(\neg \alpha)$. 
\end{enumerate}

В определении выше $\alpha$ и $\beta$ это метапеременные~--- места, куда можно подставить высказывание.
\begin{enumerate}
\item $\alpha, \beta, \gamma$~--- метапеременные для всех высказываний;
\item $X, Y, Z$~--- метапеременные для пропозициональных переменных.
\end{enumerate}

Метапеременные являются частью языка исследователя.

В формализации мы останавливаемся до места, в котором мы можем быть уверены, что сможем написать программу, которая всё проверяет.

Сокращение записи, приоритет операций: сначала $\neg$, потом $\&$, потом $\vee$, потом $\to$.
Если скобки опущены, мы восстанавливаем их по приоритетам.
Выражение без скобок является частью метаязыка и становится частью предметного, 
когда мы восстанавливаем их.
Скобки последовательных импликаций расставляются по правилу правой ассоциативности~---
справа налево.
\subsection{Теория моделей}
У нас есть истинные значения $\{T, F\}$ в классической логике. 
И есть оценка высказываний $\llbracket \alpha\rrbracket$. 
Например $\llbracket A \lor \neg A\rrbracket$ истинно.
Всё, что касается истинности высказываний, касается теории моделей. 
\begin{definition}
    Оценка~--- это функция, сопоставляющая высказыванию его истинное (истинностное) значение.
\end{definition}
\subsection{Теория доказательств}
\begin{definition}
    Аксиомы~--- это список высказываний.
    Схема аксиомы~--- высказывание вместе с метопеременными; при любой подстановке высказываний вместо метапеременной получим аксиому. 
\end{definition}

\begin{definition}
    Доказательство (вывод)~--- последовательность высказываний $\gamma_1, \gamma_2\ldots$ где $\gamma_i$--- любая аксиома, 
    либо существуют $j,k < i$ такие что $\gamma_j \equiv (\gamma_k \to \gamma_i)$.
    (знак $\equiv$ здесь сокращение для "имеет вид").
    Это правило ''перехода по следствию'' или Modus ponens.
\end{definition}

Определим следующие 10 схем аксиом для того исчисления высказываний, которое мы рассматриваем. 
\begin{enumerate}
    \item $\alpha \to \beta \to \alpha$~--- добавляет импликацию;
    \item $(\alpha \to \beta) \to (\alpha \to \beta \to \gamma) \to (\alpha \to \gamma)$~--- удаляет импликацию;
    \item $\alpha \land \beta \to \alpha$~--- удаляет конъюнкцию;
    \item $\alpha \land \beta \to \beta$;
    \item $\alpha \to \beta \to \alpha \land \beta$~--- добавляет конъюнкцию
    \item $\alpha \to \alpha \lor \beta$~--- добавляет дизьюнкцию
    \item $\beta \to \alpha \lor \beta$
    \item $(\alpha \to \gamma) \to (\beta \to \gamma) \to (\alpha \lor \beta \to \gamma)$; 
    \item $(\alpha \to \beta) \to (\alpha \to \neg \beta) \to (\neg \alpha)$ --- добавляет отрицание
    \item $\neg \neg \alpha \to \alpha$ --- снимает двойное отрицание (очень спорная штука).
\end{enumerate}

Вывод простого утверждения $A\to A$ выглядит вот так:
\begin{enumerate}\itemsep=-1mm
    \item $A\to \left( A \to A \right) \to A$ (сх. 1)
    \item $A\to A\to A$ (сх. 1)
    \item $\left( A\to A\to A \right) \to \left( A\to \left( A\to A \right) \to A \right) \to \left( A\to A \right)$ (сх. 2)
    \item $\left( A\to \left( A\to A \right) \to A \right) \to \left( A\to A \right)$ (M.P. 2, 3)
    \item $A\to A$ (M.P. 1, 3)
\end{enumerate}

\endinput
